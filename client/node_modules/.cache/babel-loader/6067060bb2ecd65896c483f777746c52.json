{"ast":null,"code":"var mapping = require('./_mapping'),\n    fallbackHolder = require('./placeholder');\n/** Built-in value reference. */\n\n\nvar push = Array.prototype.push;\n/**\r\n * Creates a function, with an arity of `n`, that invokes `func` with the\r\n * arguments it receives.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {number} n The arity of the new function.\r\n * @returns {Function} Returns the new function.\r\n */\n\nfunction baseArity(func, n) {\n  return n == 2 ? function (a, b) {\n    return func.apply(undefined, arguments);\n  } : function (a) {\n    return func.apply(undefined, arguments);\n  };\n}\n/**\r\n * Creates a function that invokes `func`, with up to `n` arguments, ignoring\r\n * any additional arguments.\r\n *\r\n * @private\r\n * @param {Function} func The function to cap arguments for.\r\n * @param {number} n The arity cap.\r\n * @returns {Function} Returns the new function.\r\n */\n\n\nfunction baseAry(func, n) {\n  return n == 2 ? function (a, b) {\n    return func(a, b);\n  } : function (a) {\n    return func(a);\n  };\n}\n/**\r\n * Creates a clone of `array`.\r\n *\r\n * @private\r\n * @param {Array} array The array to clone.\r\n * @returns {Array} Returns the cloned array.\r\n */\n\n\nfunction cloneArray(array) {\n  var length = array ? array.length : 0,\n      result = Array(length);\n\n  while (length--) {\n    result[length] = array[length];\n  }\n\n  return result;\n}\n/**\r\n * Creates a function that clones a given object using the assignment `func`.\r\n *\r\n * @private\r\n * @param {Function} func The assignment function.\r\n * @returns {Function} Returns the new cloner function.\r\n */\n\n\nfunction createCloner(func) {\n  return function (object) {\n    return func({}, object);\n  };\n}\n/**\r\n * A specialized version of `_.spread` which flattens the spread array into\r\n * the arguments of the invoked `func`.\r\n *\r\n * @private\r\n * @param {Function} func The function to spread arguments over.\r\n * @param {number} start The start position of the spread.\r\n * @returns {Function} Returns the new function.\r\n */\n\n\nfunction flatSpread(func, start) {\n  return function () {\n    var length = arguments.length,\n        lastIndex = length - 1,\n        args = Array(length);\n\n    while (length--) {\n      args[length] = arguments[length];\n    }\n\n    var array = args[start],\n        otherArgs = args.slice(0, start);\n\n    if (array) {\n      push.apply(otherArgs, array);\n    }\n\n    if (start != lastIndex) {\n      push.apply(otherArgs, args.slice(start + 1));\n    }\n\n    return func.apply(this, otherArgs);\n  };\n}\n/**\r\n * Creates a function that wraps `func` and uses `cloner` to clone the first\r\n * argument it receives.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {Function} cloner The function to clone arguments.\r\n * @returns {Function} Returns the new immutable function.\r\n */\n\n\nfunction wrapImmutable(func, cloner) {\n  return function () {\n    var length = arguments.length;\n\n    if (!length) {\n      return;\n    }\n\n    var args = Array(length);\n\n    while (length--) {\n      args[length] = arguments[length];\n    }\n\n    var result = args[0] = cloner.apply(undefined, args);\n    func.apply(undefined, args);\n    return result;\n  };\n}\n/**\r\n * The base implementation of `convert` which accepts a `util` object of methods\r\n * required to perform conversions.\r\n *\r\n * @param {Object} util The util object.\r\n * @param {string} name The name of the function to convert.\r\n * @param {Function} func The function to convert.\r\n * @param {Object} [options] The options object.\r\n * @param {boolean} [options.cap=true] Specify capping iteratee arguments.\r\n * @param {boolean} [options.curry=true] Specify currying.\r\n * @param {boolean} [options.fixed=true] Specify fixed arity.\r\n * @param {boolean} [options.immutable=true] Specify immutable operations.\r\n * @param {boolean} [options.rearg=true] Specify rearranging arguments.\r\n * @returns {Function|Object} Returns the converted function or object.\r\n */\n\n\nfunction baseConvert(util, name, func, options) {\n  var isLib = typeof name == 'function',\n      isObj = name === Object(name);\n\n  if (isObj) {\n    options = func;\n    func = name;\n    name = undefined;\n  }\n\n  if (func == null) {\n    throw new TypeError();\n  }\n\n  options || (options = {});\n  var config = {\n    'cap': 'cap' in options ? options.cap : true,\n    'curry': 'curry' in options ? options.curry : true,\n    'fixed': 'fixed' in options ? options.fixed : true,\n    'immutable': 'immutable' in options ? options.immutable : true,\n    'rearg': 'rearg' in options ? options.rearg : true\n  };\n  var defaultHolder = isLib ? func : fallbackHolder,\n      forceCurry = 'curry' in options && options.curry,\n      forceFixed = 'fixed' in options && options.fixed,\n      forceRearg = 'rearg' in options && options.rearg,\n      pristine = isLib ? func.runInContext() : undefined;\n  var helpers = isLib ? func : {\n    'ary': util.ary,\n    'assign': util.assign,\n    'clone': util.clone,\n    'curry': util.curry,\n    'forEach': util.forEach,\n    'isArray': util.isArray,\n    'isError': util.isError,\n    'isFunction': util.isFunction,\n    'isWeakMap': util.isWeakMap,\n    'iteratee': util.iteratee,\n    'keys': util.keys,\n    'rearg': util.rearg,\n    'toInteger': util.toInteger,\n    'toPath': util.toPath\n  };\n  var ary = helpers.ary,\n      assign = helpers.assign,\n      clone = helpers.clone,\n      curry = helpers.curry,\n      each = helpers.forEach,\n      isArray = helpers.isArray,\n      isError = helpers.isError,\n      isFunction = helpers.isFunction,\n      isWeakMap = helpers.isWeakMap,\n      keys = helpers.keys,\n      rearg = helpers.rearg,\n      toInteger = helpers.toInteger,\n      toPath = helpers.toPath;\n  var aryMethodKeys = keys(mapping.aryMethod);\n  var wrappers = {\n    'castArray': function (castArray) {\n      return function () {\n        var value = arguments[0];\n        return isArray(value) ? castArray(cloneArray(value)) : castArray.apply(undefined, arguments);\n      };\n    },\n    'iteratee': function (iteratee) {\n      return function () {\n        var func = arguments[0],\n            arity = arguments[1],\n            result = iteratee(func, arity),\n            length = result.length;\n\n        if (config.cap && typeof arity == 'number') {\n          arity = arity > 2 ? arity - 2 : 1;\n          return length && length <= arity ? result : baseAry(result, arity);\n        }\n\n        return result;\n      };\n    },\n    'mixin': function (mixin) {\n      return function (source) {\n        var func = this;\n\n        if (!isFunction(func)) {\n          return mixin(func, Object(source));\n        }\n\n        var pairs = [];\n        each(keys(source), function (key) {\n          if (isFunction(source[key])) {\n            pairs.push([key, func.prototype[key]]);\n          }\n        });\n        mixin(func, Object(source));\n        each(pairs, function (pair) {\n          var value = pair[1];\n\n          if (isFunction(value)) {\n            func.prototype[pair[0]] = value;\n          } else {\n            delete func.prototype[pair[0]];\n          }\n        });\n        return func;\n      };\n    },\n    'nthArg': function (nthArg) {\n      return function (n) {\n        var arity = n < 0 ? 1 : toInteger(n) + 1;\n        return curry(nthArg(n), arity);\n      };\n    },\n    'rearg': function (rearg) {\n      return function (func, indexes) {\n        var arity = indexes ? indexes.length : 0;\n        return curry(rearg(func, indexes), arity);\n      };\n    },\n    'runInContext': function (runInContext) {\n      return function (context) {\n        return baseConvert(util, runInContext(context), options);\n      };\n    }\n  };\n  /*--------------------------------------------------------------------------*/\n\n  /**\r\n   * Casts `func` to a function with an arity capped iteratee if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @returns {Function} Returns the cast function.\r\n   */\n\n  function castCap(name, func) {\n    if (config.cap) {\n      var indexes = mapping.iterateeRearg[name];\n\n      if (indexes) {\n        return iterateeRearg(func, indexes);\n      }\n\n      var n = !isLib && mapping.iterateeAry[name];\n\n      if (n) {\n        return iterateeAry(func, n);\n      }\n    }\n\n    return func;\n  }\n  /**\r\n   * Casts `func` to a curried function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity of `func`.\r\n   * @returns {Function} Returns the cast function.\r\n   */\n\n\n  function castCurry(name, func, n) {\n    return forceCurry || config.curry && n > 1 ? curry(func, n) : func;\n  }\n  /**\r\n   * Casts `func` to a fixed arity function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity cap.\r\n   * @returns {Function} Returns the cast function.\r\n   */\n\n\n  function castFixed(name, func, n) {\n    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {\n      var data = mapping.methodSpread[name],\n          start = data && data.start;\n      return start === undefined ? ary(func, n) : flatSpread(func, start);\n    }\n\n    return func;\n  }\n  /**\r\n   * Casts `func` to an rearged function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity of `func`.\r\n   * @returns {Function} Returns the cast function.\r\n   */\n\n\n  function castRearg(name, func, n) {\n    return config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]) ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n]) : func;\n  }\n  /**\r\n   * Creates a clone of `object` by `path`.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to clone.\r\n   * @param {Array|string} path The path to clone by.\r\n   * @returns {Object} Returns the cloned object.\r\n   */\n\n\n  function cloneByPath(object, path) {\n    path = toPath(path);\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        result = clone(Object(object)),\n        nested = result;\n\n    while (nested != null && ++index < length) {\n      var key = path[index],\n          value = nested[key];\n\n      if (value != null && !(isFunction(value) || isError(value) || isWeakMap(value))) {\n        nested[key] = clone(index == lastIndex ? value : Object(value));\n      }\n\n      nested = nested[key];\n    }\n\n    return result;\n  }\n  /**\r\n   * Converts `lodash` to an immutable auto-curried iteratee-first data-last\r\n   * version with conversion `options` applied.\r\n   *\r\n   * @param {Object} [options] The options object. See `baseConvert` for more details.\r\n   * @returns {Function} Returns the converted `lodash`.\r\n   */\n\n\n  function convertLib(options) {\n    return _.runInContext.convert(options)(undefined);\n  }\n  /**\r\n   * Create a converter function for `func` of `name`.\r\n   *\r\n   * @param {string} name The name of the function to convert.\r\n   * @param {Function} func The function to convert.\r\n   * @returns {Function} Returns the new converter function.\r\n   */\n\n\n  function createConverter(name, func) {\n    var realName = mapping.aliasToReal[name] || name,\n        methodName = mapping.remap[realName] || realName,\n        oldOptions = options;\n    return function (options) {\n      var newUtil = isLib ? pristine : helpers,\n          newFunc = isLib ? pristine[methodName] : func,\n          newOptions = assign(assign({}, oldOptions), options);\n      return baseConvert(newUtil, realName, newFunc, newOptions);\n    };\n  }\n  /**\r\n   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`\r\n   * arguments, ignoring any additional arguments.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to cap iteratee arguments for.\r\n   * @param {number} n The arity cap.\r\n   * @returns {Function} Returns the new function.\r\n   */\n\n\n  function iterateeAry(func, n) {\n    return overArg(func, function (func) {\n      return typeof func == 'function' ? baseAry(func, n) : func;\n    });\n  }\n  /**\r\n   * Creates a function that wraps `func` to invoke its iteratee with arguments\r\n   * arranged according to the specified `indexes` where the argument value at\r\n   * the first index is provided as the first argument, the argument value at\r\n   * the second index is provided as the second argument, and so on.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to rearrange iteratee arguments for.\r\n   * @param {number[]} indexes The arranged argument indexes.\r\n   * @returns {Function} Returns the new function.\r\n   */\n\n\n  function iterateeRearg(func, indexes) {\n    return overArg(func, function (func) {\n      var n = indexes.length;\n      return baseArity(rearg(baseAry(func, n), indexes), n);\n    });\n  }\n  /**\r\n   * Creates a function that invokes `func` with its first argument transformed.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to wrap.\r\n   * @param {Function} transform The argument transform.\r\n   * @returns {Function} Returns the new function.\r\n   */\n\n\n  function overArg(func, transform) {\n    return function () {\n      var length = arguments.length;\n\n      if (!length) {\n        return func();\n      }\n\n      var args = Array(length);\n\n      while (length--) {\n        args[length] = arguments[length];\n      }\n\n      var index = config.rearg ? 0 : length - 1;\n      args[index] = transform(args[index]);\n      return func.apply(undefined, args);\n    };\n  }\n  /**\r\n   * Creates a function that wraps `func` and applys the conversions\r\n   * rules by `name`.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to wrap.\r\n   * @param {Function} func The function to wrap.\r\n   * @returns {Function} Returns the converted function.\r\n   */\n\n\n  function wrap(name, func, placeholder) {\n    var result,\n        realName = mapping.aliasToReal[name] || name,\n        wrapped = func,\n        wrapper = wrappers[realName];\n\n    if (wrapper) {\n      wrapped = wrapper(func);\n    } else if (config.immutable) {\n      if (mapping.mutate.array[realName]) {\n        wrapped = wrapImmutable(func, cloneArray);\n      } else if (mapping.mutate.object[realName]) {\n        wrapped = wrapImmutable(func, createCloner(func));\n      } else if (mapping.mutate.set[realName]) {\n        wrapped = wrapImmutable(func, cloneByPath);\n      }\n    }\n\n    each(aryMethodKeys, function (aryKey) {\n      each(mapping.aryMethod[aryKey], function (otherName) {\n        if (realName == otherName) {\n          var data = mapping.methodSpread[realName],\n              afterRearg = data && data.afterRearg;\n          result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);\n          result = castCap(realName, result);\n          result = castCurry(realName, result, aryKey);\n          return false;\n        }\n      });\n      return !result;\n    });\n    result || (result = wrapped);\n\n    if (result == func) {\n      result = forceCurry ? curry(result, 1) : function () {\n        return func.apply(this, arguments);\n      };\n    }\n\n    result.convert = createConverter(realName, func);\n    result.placeholder = func.placeholder = placeholder;\n    return result;\n  }\n  /*--------------------------------------------------------------------------*/\n\n\n  if (!isObj) {\n    return wrap(name, func, defaultHolder);\n  }\n\n  var _ = func; // Convert methods by ary cap.\n\n  var pairs = [];\n  each(aryMethodKeys, function (aryKey) {\n    each(mapping.aryMethod[aryKey], function (key) {\n      var func = _[mapping.remap[key] || key];\n\n      if (func) {\n        pairs.push([key, wrap(key, func, _)]);\n      }\n    });\n  }); // Convert remaining methods.\n\n  each(keys(_), function (key) {\n    var func = _[key];\n\n    if (typeof func == 'function') {\n      var length = pairs.length;\n\n      while (length--) {\n        if (pairs[length][0] == key) {\n          return;\n        }\n      }\n\n      func.convert = createConverter(key, func);\n      pairs.push([key, func]);\n    }\n  }); // Assign to `_` leaving `_.prototype` unchanged to allow chaining.\n\n  each(pairs, function (pair) {\n    _[pair[0]] = pair[1];\n  });\n  _.convert = convertLib;\n  _.placeholder = _; // Assign aliases.\n\n  each(keys(_), function (key) {\n    each(mapping.realToAlias[key] || [], function (alias) {\n      _[alias] = _[key];\n    });\n  });\n  return _;\n}\n\nmodule.exports = baseConvert;","map":{"version":3,"sources":["C:/Projects/StudyManagement/client/node_modules/lodash/fp/_baseConvert.js"],"names":["mapping","require","fallbackHolder","push","Array","prototype","baseArity","func","n","a","b","apply","undefined","arguments","baseAry","cloneArray","array","length","result","createCloner","object","flatSpread","start","lastIndex","args","otherArgs","slice","wrapImmutable","cloner","baseConvert","util","name","options","isLib","isObj","Object","TypeError","config","cap","curry","fixed","immutable","rearg","defaultHolder","forceCurry","forceFixed","forceRearg","pristine","runInContext","helpers","ary","assign","clone","forEach","isArray","isError","isFunction","isWeakMap","iteratee","keys","toInteger","toPath","each","aryMethodKeys","aryMethod","wrappers","castArray","value","arity","mixin","source","pairs","key","pair","nthArg","indexes","context","castCap","iterateeRearg","iterateeAry","castCurry","castFixed","skipFixed","data","methodSpread","castRearg","skipRearg","methodRearg","aryRearg","cloneByPath","path","index","nested","convertLib","_","convert","createConverter","realName","aliasToReal","methodName","remap","oldOptions","newUtil","newFunc","newOptions","overArg","transform","wrap","placeholder","wrapped","wrapper","mutate","set","aryKey","otherName","afterRearg","realToAlias","alias","module","exports"],"mappings":"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","sourcesContent":["var mapping = require('./_mapping'),\r\n    fallbackHolder = require('./placeholder');\r\n\r\n/** Built-in value reference. */\r\nvar push = Array.prototype.push;\r\n\r\n/**\r\n * Creates a function, with an arity of `n`, that invokes `func` with the\r\n * arguments it receives.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {number} n The arity of the new function.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction baseArity(func, n) {\r\n  return n == 2\r\n    ? function(a, b) { return func.apply(undefined, arguments); }\r\n    : function(a) { return func.apply(undefined, arguments); };\r\n}\r\n\r\n/**\r\n * Creates a function that invokes `func`, with up to `n` arguments, ignoring\r\n * any additional arguments.\r\n *\r\n * @private\r\n * @param {Function} func The function to cap arguments for.\r\n * @param {number} n The arity cap.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction baseAry(func, n) {\r\n  return n == 2\r\n    ? function(a, b) { return func(a, b); }\r\n    : function(a) { return func(a); };\r\n}\r\n\r\n/**\r\n * Creates a clone of `array`.\r\n *\r\n * @private\r\n * @param {Array} array The array to clone.\r\n * @returns {Array} Returns the cloned array.\r\n */\r\nfunction cloneArray(array) {\r\n  var length = array ? array.length : 0,\r\n      result = Array(length);\r\n\r\n  while (length--) {\r\n    result[length] = array[length];\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Creates a function that clones a given object using the assignment `func`.\r\n *\r\n * @private\r\n * @param {Function} func The assignment function.\r\n * @returns {Function} Returns the new cloner function.\r\n */\r\nfunction createCloner(func) {\r\n  return function(object) {\r\n    return func({}, object);\r\n  };\r\n}\r\n\r\n/**\r\n * A specialized version of `_.spread` which flattens the spread array into\r\n * the arguments of the invoked `func`.\r\n *\r\n * @private\r\n * @param {Function} func The function to spread arguments over.\r\n * @param {number} start The start position of the spread.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction flatSpread(func, start) {\r\n  return function() {\r\n    var length = arguments.length,\r\n        lastIndex = length - 1,\r\n        args = Array(length);\r\n\r\n    while (length--) {\r\n      args[length] = arguments[length];\r\n    }\r\n    var array = args[start],\r\n        otherArgs = args.slice(0, start);\r\n\r\n    if (array) {\r\n      push.apply(otherArgs, array);\r\n    }\r\n    if (start != lastIndex) {\r\n      push.apply(otherArgs, args.slice(start + 1));\r\n    }\r\n    return func.apply(this, otherArgs);\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a function that wraps `func` and uses `cloner` to clone the first\r\n * argument it receives.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {Function} cloner The function to clone arguments.\r\n * @returns {Function} Returns the new immutable function.\r\n */\r\nfunction wrapImmutable(func, cloner) {\r\n  return function() {\r\n    var length = arguments.length;\r\n    if (!length) {\r\n      return;\r\n    }\r\n    var args = Array(length);\r\n    while (length--) {\r\n      args[length] = arguments[length];\r\n    }\r\n    var result = args[0] = cloner.apply(undefined, args);\r\n    func.apply(undefined, args);\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * The base implementation of `convert` which accepts a `util` object of methods\r\n * required to perform conversions.\r\n *\r\n * @param {Object} util The util object.\r\n * @param {string} name The name of the function to convert.\r\n * @param {Function} func The function to convert.\r\n * @param {Object} [options] The options object.\r\n * @param {boolean} [options.cap=true] Specify capping iteratee arguments.\r\n * @param {boolean} [options.curry=true] Specify currying.\r\n * @param {boolean} [options.fixed=true] Specify fixed arity.\r\n * @param {boolean} [options.immutable=true] Specify immutable operations.\r\n * @param {boolean} [options.rearg=true] Specify rearranging arguments.\r\n * @returns {Function|Object} Returns the converted function or object.\r\n */\r\nfunction baseConvert(util, name, func, options) {\r\n  var isLib = typeof name == 'function',\r\n      isObj = name === Object(name);\r\n\r\n  if (isObj) {\r\n    options = func;\r\n    func = name;\r\n    name = undefined;\r\n  }\r\n  if (func == null) {\r\n    throw new TypeError;\r\n  }\r\n  options || (options = {});\r\n\r\n  var config = {\r\n    'cap': 'cap' in options ? options.cap : true,\r\n    'curry': 'curry' in options ? options.curry : true,\r\n    'fixed': 'fixed' in options ? options.fixed : true,\r\n    'immutable': 'immutable' in options ? options.immutable : true,\r\n    'rearg': 'rearg' in options ? options.rearg : true\r\n  };\r\n\r\n  var defaultHolder = isLib ? func : fallbackHolder,\r\n      forceCurry = ('curry' in options) && options.curry,\r\n      forceFixed = ('fixed' in options) && options.fixed,\r\n      forceRearg = ('rearg' in options) && options.rearg,\r\n      pristine = isLib ? func.runInContext() : undefined;\r\n\r\n  var helpers = isLib ? func : {\r\n    'ary': util.ary,\r\n    'assign': util.assign,\r\n    'clone': util.clone,\r\n    'curry': util.curry,\r\n    'forEach': util.forEach,\r\n    'isArray': util.isArray,\r\n    'isError': util.isError,\r\n    'isFunction': util.isFunction,\r\n    'isWeakMap': util.isWeakMap,\r\n    'iteratee': util.iteratee,\r\n    'keys': util.keys,\r\n    'rearg': util.rearg,\r\n    'toInteger': util.toInteger,\r\n    'toPath': util.toPath\r\n  };\r\n\r\n  var ary = helpers.ary,\r\n      assign = helpers.assign,\r\n      clone = helpers.clone,\r\n      curry = helpers.curry,\r\n      each = helpers.forEach,\r\n      isArray = helpers.isArray,\r\n      isError = helpers.isError,\r\n      isFunction = helpers.isFunction,\r\n      isWeakMap = helpers.isWeakMap,\r\n      keys = helpers.keys,\r\n      rearg = helpers.rearg,\r\n      toInteger = helpers.toInteger,\r\n      toPath = helpers.toPath;\r\n\r\n  var aryMethodKeys = keys(mapping.aryMethod);\r\n\r\n  var wrappers = {\r\n    'castArray': function(castArray) {\r\n      return function() {\r\n        var value = arguments[0];\r\n        return isArray(value)\r\n          ? castArray(cloneArray(value))\r\n          : castArray.apply(undefined, arguments);\r\n      };\r\n    },\r\n    'iteratee': function(iteratee) {\r\n      return function() {\r\n        var func = arguments[0],\r\n            arity = arguments[1],\r\n            result = iteratee(func, arity),\r\n            length = result.length;\r\n\r\n        if (config.cap && typeof arity == 'number') {\r\n          arity = arity > 2 ? (arity - 2) : 1;\r\n          return (length && length <= arity) ? result : baseAry(result, arity);\r\n        }\r\n        return result;\r\n      };\r\n    },\r\n    'mixin': function(mixin) {\r\n      return function(source) {\r\n        var func = this;\r\n        if (!isFunction(func)) {\r\n          return mixin(func, Object(source));\r\n        }\r\n        var pairs = [];\r\n        each(keys(source), function(key) {\r\n          if (isFunction(source[key])) {\r\n            pairs.push([key, func.prototype[key]]);\r\n          }\r\n        });\r\n\r\n        mixin(func, Object(source));\r\n\r\n        each(pairs, function(pair) {\r\n          var value = pair[1];\r\n          if (isFunction(value)) {\r\n            func.prototype[pair[0]] = value;\r\n          } else {\r\n            delete func.prototype[pair[0]];\r\n          }\r\n        });\r\n        return func;\r\n      };\r\n    },\r\n    'nthArg': function(nthArg) {\r\n      return function(n) {\r\n        var arity = n < 0 ? 1 : (toInteger(n) + 1);\r\n        return curry(nthArg(n), arity);\r\n      };\r\n    },\r\n    'rearg': function(rearg) {\r\n      return function(func, indexes) {\r\n        var arity = indexes ? indexes.length : 0;\r\n        return curry(rearg(func, indexes), arity);\r\n      };\r\n    },\r\n    'runInContext': function(runInContext) {\r\n      return function(context) {\r\n        return baseConvert(util, runInContext(context), options);\r\n      };\r\n    }\r\n  };\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * Casts `func` to a function with an arity capped iteratee if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @returns {Function} Returns the cast function.\r\n   */\r\n  function castCap(name, func) {\r\n    if (config.cap) {\r\n      var indexes = mapping.iterateeRearg[name];\r\n      if (indexes) {\r\n        return iterateeRearg(func, indexes);\r\n      }\r\n      var n = !isLib && mapping.iterateeAry[name];\r\n      if (n) {\r\n        return iterateeAry(func, n);\r\n      }\r\n    }\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Casts `func` to a curried function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity of `func`.\r\n   * @returns {Function} Returns the cast function.\r\n   */\r\n  function castCurry(name, func, n) {\r\n    return (forceCurry || (config.curry && n > 1))\r\n      ? curry(func, n)\r\n      : func;\r\n  }\r\n\r\n  /**\r\n   * Casts `func` to a fixed arity function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity cap.\r\n   * @returns {Function} Returns the cast function.\r\n   */\r\n  function castFixed(name, func, n) {\r\n    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {\r\n      var data = mapping.methodSpread[name],\r\n          start = data && data.start;\r\n\r\n      return start  === undefined ? ary(func, n) : flatSpread(func, start);\r\n    }\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Casts `func` to an rearged function if needed.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to inspect.\r\n   * @param {Function} func The function to inspect.\r\n   * @param {number} n The arity of `func`.\r\n   * @returns {Function} Returns the cast function.\r\n   */\r\n  function castRearg(name, func, n) {\r\n    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))\r\n      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])\r\n      : func;\r\n  }\r\n\r\n  /**\r\n   * Creates a clone of `object` by `path`.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to clone.\r\n   * @param {Array|string} path The path to clone by.\r\n   * @returns {Object} Returns the cloned object.\r\n   */\r\n  function cloneByPath(object, path) {\r\n    path = toPath(path);\r\n\r\n    var index = -1,\r\n        length = path.length,\r\n        lastIndex = length - 1,\r\n        result = clone(Object(object)),\r\n        nested = result;\r\n\r\n    while (nested != null && ++index < length) {\r\n      var key = path[index],\r\n          value = nested[key];\r\n\r\n      if (value != null &&\r\n          !(isFunction(value) || isError(value) || isWeakMap(value))) {\r\n        nested[key] = clone(index == lastIndex ? value : Object(value));\r\n      }\r\n      nested = nested[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts `lodash` to an immutable auto-curried iteratee-first data-last\r\n   * version with conversion `options` applied.\r\n   *\r\n   * @param {Object} [options] The options object. See `baseConvert` for more details.\r\n   * @returns {Function} Returns the converted `lodash`.\r\n   */\r\n  function convertLib(options) {\r\n    return _.runInContext.convert(options)(undefined);\r\n  }\r\n\r\n  /**\r\n   * Create a converter function for `func` of `name`.\r\n   *\r\n   * @param {string} name The name of the function to convert.\r\n   * @param {Function} func The function to convert.\r\n   * @returns {Function} Returns the new converter function.\r\n   */\r\n  function createConverter(name, func) {\r\n    var realName = mapping.aliasToReal[name] || name,\r\n        methodName = mapping.remap[realName] || realName,\r\n        oldOptions = options;\r\n\r\n    return function(options) {\r\n      var newUtil = isLib ? pristine : helpers,\r\n          newFunc = isLib ? pristine[methodName] : func,\r\n          newOptions = assign(assign({}, oldOptions), options);\r\n\r\n      return baseConvert(newUtil, realName, newFunc, newOptions);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`\r\n   * arguments, ignoring any additional arguments.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to cap iteratee arguments for.\r\n   * @param {number} n The arity cap.\r\n   * @returns {Function} Returns the new function.\r\n   */\r\n  function iterateeAry(func, n) {\r\n    return overArg(func, function(func) {\r\n      return typeof func == 'function' ? baseAry(func, n) : func;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a function that wraps `func` to invoke its iteratee with arguments\r\n   * arranged according to the specified `indexes` where the argument value at\r\n   * the first index is provided as the first argument, the argument value at\r\n   * the second index is provided as the second argument, and so on.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to rearrange iteratee arguments for.\r\n   * @param {number[]} indexes The arranged argument indexes.\r\n   * @returns {Function} Returns the new function.\r\n   */\r\n  function iterateeRearg(func, indexes) {\r\n    return overArg(func, function(func) {\r\n      var n = indexes.length;\r\n      return baseArity(rearg(baseAry(func, n), indexes), n);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a function that invokes `func` with its first argument transformed.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to wrap.\r\n   * @param {Function} transform The argument transform.\r\n   * @returns {Function} Returns the new function.\r\n   */\r\n  function overArg(func, transform) {\r\n    return function() {\r\n      var length = arguments.length;\r\n      if (!length) {\r\n        return func();\r\n      }\r\n      var args = Array(length);\r\n      while (length--) {\r\n        args[length] = arguments[length];\r\n      }\r\n      var index = config.rearg ? 0 : (length - 1);\r\n      args[index] = transform(args[index]);\r\n      return func.apply(undefined, args);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates a function that wraps `func` and applys the conversions\r\n   * rules by `name`.\r\n   *\r\n   * @private\r\n   * @param {string} name The name of the function to wrap.\r\n   * @param {Function} func The function to wrap.\r\n   * @returns {Function} Returns the converted function.\r\n   */\r\n  function wrap(name, func, placeholder) {\r\n    var result,\r\n        realName = mapping.aliasToReal[name] || name,\r\n        wrapped = func,\r\n        wrapper = wrappers[realName];\r\n\r\n    if (wrapper) {\r\n      wrapped = wrapper(func);\r\n    }\r\n    else if (config.immutable) {\r\n      if (mapping.mutate.array[realName]) {\r\n        wrapped = wrapImmutable(func, cloneArray);\r\n      }\r\n      else if (mapping.mutate.object[realName]) {\r\n        wrapped = wrapImmutable(func, createCloner(func));\r\n      }\r\n      else if (mapping.mutate.set[realName]) {\r\n        wrapped = wrapImmutable(func, cloneByPath);\r\n      }\r\n    }\r\n    each(aryMethodKeys, function(aryKey) {\r\n      each(mapping.aryMethod[aryKey], function(otherName) {\r\n        if (realName == otherName) {\r\n          var data = mapping.methodSpread[realName],\r\n              afterRearg = data && data.afterRearg;\r\n\r\n          result = afterRearg\r\n            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)\r\n            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);\r\n\r\n          result = castCap(realName, result);\r\n          result = castCurry(realName, result, aryKey);\r\n          return false;\r\n        }\r\n      });\r\n      return !result;\r\n    });\r\n\r\n    result || (result = wrapped);\r\n    if (result == func) {\r\n      result = forceCurry ? curry(result, 1) : function() {\r\n        return func.apply(this, arguments);\r\n      };\r\n    }\r\n    result.convert = createConverter(realName, func);\r\n    result.placeholder = func.placeholder = placeholder;\r\n\r\n    return result;\r\n  }\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  if (!isObj) {\r\n    return wrap(name, func, defaultHolder);\r\n  }\r\n  var _ = func;\r\n\r\n  // Convert methods by ary cap.\r\n  var pairs = [];\r\n  each(aryMethodKeys, function(aryKey) {\r\n    each(mapping.aryMethod[aryKey], function(key) {\r\n      var func = _[mapping.remap[key] || key];\r\n      if (func) {\r\n        pairs.push([key, wrap(key, func, _)]);\r\n      }\r\n    });\r\n  });\r\n\r\n  // Convert remaining methods.\r\n  each(keys(_), function(key) {\r\n    var func = _[key];\r\n    if (typeof func == 'function') {\r\n      var length = pairs.length;\r\n      while (length--) {\r\n        if (pairs[length][0] == key) {\r\n          return;\r\n        }\r\n      }\r\n      func.convert = createConverter(key, func);\r\n      pairs.push([key, func]);\r\n    }\r\n  });\r\n\r\n  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.\r\n  each(pairs, function(pair) {\r\n    _[pair[0]] = pair[1];\r\n  });\r\n\r\n  _.convert = convertLib;\r\n  _.placeholder = _;\r\n\r\n  // Assign aliases.\r\n  each(keys(_), function(key) {\r\n    each(mapping.realToAlias[key] || [], function(alias) {\r\n      _[alias] = _[key];\r\n    });\r\n  });\r\n\r\n  return _;\r\n}\r\n\r\nmodule.exports = baseConvert;\r\n"]},"metadata":{},"sourceType":"script"}